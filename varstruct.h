// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Varstruct creates struct-like types with runtime-computed array sizes.
//
// C-style struct definitions may have internal array fields; however, these
// field declarations must specify the size of each array at compile time so
// that the compiler may reserve enough space when computing the offset of each
// member and the size of the struct.
//
// Unfortunately, many I/O protocols use headers with internal arrays whose size
// is specified or computed based on other header fields. Therefore, code that
// parses these headers often has to perform error-prone manual pointer
// manipulation.
//
// Varstruct is a C++11 library that creates types that may contains internal
// arrays, and the sizes of these arrays may be passed in at runtime. Varstruct
// then computes offsets to each member, and can also read and modify fields
// when given an input pointer.
//
// (Modification is performed via std::memcpy() to avoid memory alignment
// problems that would otherwise occur accessing misaligned fields -- Varstruct
// doesn't add any padding of its own).
//
// Varstruct definitions look like struct or class definitions:
//
// DEFINE_VARSTRUCT(SimpleStruct) {
//   VARSTRUCT_SCALAR(int, foo);
//   VARSTRUCT_ARRAY(char, bar);
// };
//
// This creates a new type, SimpleStruct. The Create() method should be used to
// create instances of SimpleStruct:
//
// auto simple_struct = SimpleStruct::Create({5, 8});
//
// Here, we are specifying that bar has 5 cells and baz has 8. The following
// methods will be generated:
//
// These methods are generated for every Varstruct, independant of any other
// VARSTRUCT_*() declaration:
//
// static Create() -- Creates a varstruct given an optional pointer and a brace
//                    list of array sizes.
//
// num_members() -- Returns the number of VARSTRUCT_SCALAR() declarations plus
//                  the number of VARSTRUCT_ARRAY() declarations.
//
// size_bytes() -- Returns the size of the entire varstruct, in bytes.
//
// These methods get generated by VARSTRUCT_SCALAR() and VARSTRUCT_ARRAY()
// declarations:
//
// static std::size_t foo_size() -- Returns the size of foo in bytes. This
//                                  method is static as the size is known at
//                                  compile time.
// std::size_t foo_offset() -- Returns the offset of foo in SimpleStruct.
//
// std::size_t bar_size() -- Returns the size of all cells of bar in bytes.
// std::size_t bar_offset() -- Returns the offset of bar in SimpleStruct.
//
// A base pointer may also be provided to Create() in addition to the brace-list
// of array sizes:
//
// auto simple_struct = SimpleStruct::Create(my_ptr, {5, 8});
//
// With this pointer provided, the following extra methods will be generated:
//
// int foo() -- Returns the value of foo.
// char bar(size_t index) -- Returns the 0-indexed element of bar given by
//                           index.
//
// Bounds checks are performed by default. To disable this, use the bounds_check
// template parameter:
//
// x = bar</*bounds_check=*/false>(100);
//
// If the pointer is to a non-const type, modifier methods will also be
// generated:
//
// void set_foo(int value) -- Sets foo to value.
// void set_bar(size_t index, char value) -- Sets the 0-indexed element of bar
//                                           given by index to value.
//
// Again, bounds checks may be disabled for modifier methods:
//
// set_bar</*bounds_check=*/false>(100, 'a');
//
// Attempting to use pointer accessor without passing the appropriate pointer to
// Create() will result in a compilation error.
//
// As each Create() overload returns a different template instantiation of
// SimpleStruct, you should use "auto" declarations with the Create()
// method so that you don't have to reference Varstruct internals, which may
// change in future versions.
//
// Example usages of this library may be found in varstruct_test.cc.
//
// Only functionality documented in this header and in varstruct_test.cc is
// supported -- attempting to access Varstruct internals may result in
// breakage when Varstruct changes.

#ifndef VARSTRUCT_VARSTRUCT_H_
#define VARSTRUCT_VARSTRUCT_H_

#include "varstruct_internal.h"

// Opens a Varstruct definition.
//
// Consider DEFINE_VARSTRUCT(Foo) like writing "struct Foo"; it generates a new
// type "Foo", and it must be followed by a body containing VARSTRUCT_SCALAR()
// and VARSTRUCT_ARRAY() declarations. The final brace should be closed by a
// semicolon. Do not place anything in the body other than VARSTRUCT_SCALAR()
// and VARSTRUCT_ARRAY() declarations.
//
// Varstructs may not be defined inside of classes or methods as they use
// template definitions internally. They may be used inside namespaces, however.
#define DEFINE_VARSTRUCT(name) DEFINE_VARSTRUCT_INTERNAL(name)

// Declare a scalar field inside the Varstruct.
//
// Scalars are like typical struct members in that their size is determined by
// their type, and not changed at runtime.
#define VARSTRUCT_SCALAR(decl_type, name) \
  VARSTRUCT_SCALAR_INTERNAL(decl_type, name)

// Declare an array field in the Varstruct.
//
// Sizes of each array field are passed in braces to the Create() method in the
// resultant Varstruct type in the order matching the order of declaration and
// number of VARSTRUCT_ARRAY() elements. These sizes may vary at runtime -- that
// is the key difference between a Varstruct and a C-style struct.
#define VARSTRUCT_ARRAY(decl_type, name) \
  VARSTRUCT_ARRAY_INTERNAL(decl_type, name)

#endif  // VARSTRUCT_VARSTRUCT_H_
